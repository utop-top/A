# ==========================================================
# 全局设置 (Global Settings)
# ==========================================================
global
    # 日志输出到标准输出，方便 Docker Compose 或 Systemd 捕获
    #log stdout local0 notice
    #    format raw 防止 Docker 日志中出现重复的时间戳
    log stdout format raw local0 info
    # 最大的并发连接数
    maxconn 8192 
    # 切换用户和组
#    user haproxy
#    group haproxy
    # 以守护进程模式运行
    daemon

defaults
    # 启用详细的 TCP 日志记录 (非常重要)
    option tcplog

    # 显示格式: [时间] 客户端IP -> 目标IP | SNI域名: [域名] | 转发到: [后端名称]
    #log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc | SNI: %[fc_pp_authority,map_pcre] %[ssl_fc_sni] | Backend: %b"
    log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc | SNI: %[req.ssl_sni] | Backend: %b"
    log global
    # 设置为 TCP 模式，用于四层转发
    mode tcp 
    # 各种超时设置 (推荐的长连接设置)
    timeout connect 5s     # 连接到后端超时
    timeout client 3600s   # 客户端空闲超时 (60分钟)
    timeout server 3600s   # 服务器空闲超时 (60分钟)
    # 性能优化
    no option http-server-close
    option tcplog          # 启用 TCP 日志记录

# ==========================================================
# 1. 后端定义 (Backends)
# ==========================================================


# 后端 A: Signal 服务 (纯 TCP/TLS 后端)
#backend bk_signal_tcp
#    mode tcp
#    # 纯转发，不注入 PROXY Protocol，确保 Signal 兼容
#    # ⚠️ 请替换为您的 Signal 服务监听地址和端口
#    server s1 127.0.0.1:4433 check 

# 后端 A: matrix synapse 
backend bk_t_nginx_http
    mode tcp
    server s1 127.0.0.1:4441 check send-proxy-v2

# 后端 B: Nginx HTTP/Matrix 服务 (需要 PROXY Protocol)
backend bk_nginx_http
    mode tcp
    # 注入 PROXY Protocol v2 头部 (二进制格式)
    # ⚠️ 请替换为您的 Nginx L7 代理监听地址和端口
    server s1 127.0.0.1:4443 check send-proxy-v2

backend bk_t_nginx_acme
    mode http
    server s1 127.0.0.1:8001 check 

backend bk_host_nginx_acme
    mode http
    server s1 127.0.0.1:8081 check

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# 新增服务 A
#backend bk_mail_service
#    mode tcp
#    # 只要加上 send-proxy-v2 就是注入
#    server s1 127.0.0.1:5000 check send-proxy-v2




frontend http-in
    bind *:80
    mode http
    option httplog
    
    # 定义 ACL
    acl acme_challenge path_beg /.well-known/acme-challenge/
    
    # hdr(host) 读取 Host 头，-i 表示不区分大小写
    # 可以写多个域名，用空格隔开
    acl is_my_domains hdr(host) -i m.aosn.de account.aosn.de admin.aosn.de matrix.aosn.de
    # 3. 逻辑处理：
    # 规则：必须同时满足 "是 ACME 路径" 和 "是我的域名" 才转发
    use_backend bk_t_nginx_acme if acme_challenge is_my_domains

    # 【优先级 2】: 是 ACME 路径 (剩下的所有域名都会落到这里) -> 走 8081
    use_backend bk_host_nginx_acme if acme_challenge

    # 【优先级 3】: 非 ACME 请求 (普通访问) -> 强制跳转 HTTPS
    http-request redirect scheme https unless { ssl_fc }

# ==========================================================
# 2. 统一入口前端 (Frontend)
#    监听 443 端口，进行 SNI 分流和协议控制
# ==========================================================
frontend ft_https_unified
    # 绑定 443 端口 (假设使用 Host 网络模式)
    bind *:443
    mode tcp
  
    # 启用 SSL/TLS Hello 检查和延迟，以读取 SNI 域名
    tcp-request inspect-delay 5s 
    tcp-request content accept if { req_ssl_hello_type 1 } 
    
    # 步骤 A: 定义 ACLs (Access Control Lists)
    # ACL 检查 SNI 域名是否匹配 Signal 服务
    # ⚠️ 请将 s2.imtx.dpdns.org 替换为您的实际 Signal 域名
    acl is_t_nginx_domain req_ssl_sni -i m.aosn.de account.aosn.de admin.aosn.de matrix.aosn.de
    default_backend bk_nginx_http

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    # 新增 ACL
#    acl is_mail   req_ssl_sni -i mail.aosn.de
#    acl is_admin  req_ssl_sni -i admin.aosn.de
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    # 步骤 B: 根据 ACLs 进行分流和转发
    
    # 规则 1: 如果是 Signal 域名，转发到 bk_t_nginx_http (纯转发)
    use_backend bk_t_nginx_http if is_t_nginx_domain


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 #   # 新增路由
#    use_backend bk_mail_service  if is_mail
#    use_backend bk_admin_panel   if is_admin
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  
    
    # 规则 2: 否则 (默认为 HTTP/Matrix 流量)，转发到 bk_nginx_http 
    #       (bk_nginx_http 后端已配置 send-proxy-v2)
    default_backend bk_nginx_http
